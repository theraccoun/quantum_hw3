\documentclass[12pt]{article}
\usepackage{amsmath}
\newcommand{\piRsquare}{\pi r^2}

\title{Quant. Comp. HW - 2}
\author{Steven MacCoun}
\date{Oct. 18, 2005}

\begin{document}
\maketitle						% automatic title!



\section{Simon's Problem}
00110011000011101001100000111111110111101100000010000001001110011010100001
110001001000001110111000101001001011001010010010010001

\section{Modular Exponentiation}

Here was my python code:

\begin{verbatim}
#Modular Exponentiation
import math

def modular_exponentiation(base, exponent, modulus):
         c = 1
         for e_prime in range(1, exponent+1):
                    c = (c * base) % modulus
        return c

print modular_exponentiation(1234, 1234*1234, math.pow(10, 10))
\end{verbatim}
And the output was: \[\boxed{3102217216.0}\] 


\section{RSA Misuse}

I first tried to solve this as strictly a math problem, but had little success, in large part because I thought that
the gcd(e1, e2) was somehow irrelevant to the problem. However, I noticed that normally the exponents are the same value
when performing RSA, so I scoured google to see if there was some well known attack where you have a common modulus with
different attacks. Turns out that it is fairly well documented, and Simmons wrote a paper on it a while back.

The basic idea is:
Since \[gcd(e_1,e_2) = 1\],
then \[\exists u, v   \;  s.t.   \;  e_1*u + e_2*v = 1\]
To solve for u and v, I used the extended Euclidean algorithm.
I found the key step using next using http://www-math.ucdenver.edu/~wcherowi/courses/m5410/ctcpf.html.
\\Since u is the multiplicative inverse of $e_1$ mod $e_2$, I can set  \[d = u \% e_2\] \[f = (db-1)/c\]
From this I can multiply $c1^d$ and $(c2^f)^{-1}$: \[c1^d * (c2^f)^{-1} = M^{bd}M^{-ce} = M^{bd-ce}=M mod  \; n\]
Because my modular exponentiation code can't handle negatives, note that $c2^{-f} \; mod \; n = c2^{n-f} mod \; n$
My attached code computes: \[c1^d * c2^{n-f} mod \; n\] As the following big ass number:
\\673370853263257965646963259179397225628008143563852220775606027852825698\\78305166652681510415055212454150081059
\\4303492288369096736114191743795403582324250444021435304630
\\3868456928963315339456746860255392803655465512


\section{Prime factorization}

Problem: Consider n=121932632103337941464563328643500519
\\\\(a) How many bits is n?
\begin{verbatim}
print len(str(121932632103337941464563328643500519))
\end{verbatim}
Output:  \[\boxed{36}\] 
\\(b) Find if n is prime with program that runs in less than one second.
\begin{verbatim}
def miller_rabin_pass(a, s, d, n):
         a_to_power = pow(a, d, n)
         if a_to_power == 1:
                   return True
         for i in xrange(s-1):
                if a_to_power == n - 1:
                          return True
                a_to_power = (a_to_power * a_to_power) % n
        return a_to_power == n - 1

def miller_rabin(n):
        #compute s and d
         d = n - 1
         s = 0
        while d % 2 == 0:
                  d >>= 1
                  s += 1

         #Run several miller_rabin passes
         for repeat in xrange(20):
                   a = randint(2, n-1)
                   if not miller_rabin_pass(a, s, d, n):
                            return False
         return True

print miller_rabin(n)
\end{verbatim}

(b)

(c)

(d)

(e)



\end{document} 


